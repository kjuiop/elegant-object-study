# 내용 정리

- 상속에 반대하는 강력한 주장은 상속이 객체들의 관계를 너무 복잡하게 만든다는 것이다.
- 클래스를 쌓아 만든 피라미드의 높이가 5단계를 넘어가는 순간부터는 상속 관계로 연결된 클래스의 계층 구조를 이해하기 어려워진다.
- 근본적인 원인은 상속이 아니라 가상 메서드(virtual method)이다.
- 상속은 자식 클래스가 부모 클래스의 코드를 계승받는 하향식 프로세스이다. 자식이 부모의 유산에 접근하는 일반적인 상속과 달리 메서드 오버라이 등은 부모가 자식의 코드에 접근하는 것을 가능하게 한다. 이건 정반대의 사고방식이다.
- 상속이 유지보수성을 해치는 근본적인 문제이다.
- 하지만 클래스와 메서드를 `final`이나 `abstract` 둘 중 하나로만 제한한다면 문제가 발생할 수 있는 가능성을 없앨 수 있다. `final` 클래스는 상속을 받을 수 없다. 또한 메서드가 `abstract`라면  부모의 클래스가 구현을 할 수 없기 때문에 혼란을 막아준다.
- 클래스가 가질 수 있는 신 분 세가지
    - `final`
        - 블랙 박스
        - 불투명하고 독립적이며 어떻게 행동해야할지 알고 있고 도움이 필요 없다.
    - `abstract`
        - 글래스 박스
        - 불완전
        - 스스로 행동할 수 없고 누군가의 도움이 필요하며 일부 요소가 누락
        - 기술적인 관점에서는 클래스가 아니며 클래스를 위한 원재료의 느낌
    - 일반
        - 어느쪽도 아니다.
        - 저자는 매우 반대
        - 불완전하지만 불투명하고 자립적이며 견고하다고 자부하는 클래스
- 상속이 적절한 경우
    - 클래스의 행동을 확장(extend)하지 않고 정제(refine)할 때
    - 확장이라는 프로세스는 원하지 않는 경우에도 객체를 글래스 박스로 취급하기 떄문에 OOP에서는 어떤 것도 ‘확장’할 수 없어야 한다. 객체는 블랙박스로 취급되도록 설계되었기 때문에 객체에 침입해서 내부의 결속력을 훼손시킬 것이라고 예상하지 않는다. 클래스 확장은 곧 침범(intrusion)을 의미한다.

# 느낀점

- 정제할 때 상속을 해야한다는데, 정제하기 위한 상속을 하도록 만들었을까 싶긴 하다.
- 오히려 느슨한 개념으로 OOP를 이해해야한다는 확신이 드는 챕터이다. 상속이라는 개념은 트렌디하진 않지만 객체지향의 핵심이었던 개념이다. 현재는 조합(composition)의 방법으로 상속을 대체하는 방법을 제시하는 경우가 많은데, 이 책은 애매한 결론을 내렸다. 개발에서 대체할 수 없는 방법을 내리는 것은 수준이 높다고 볼 수 없다.
