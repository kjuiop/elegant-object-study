### 정리

---

- 상속은 객체들의 관계를 너무 복잡하게 만듭니다
    - 하지만 근본적인 원인는 상속 그 자체가 아니라 가상메서드입니다.
    - 메서드 오버라이딩은 직관적인 상속의 개념에 어긋나는 사고방식이다.
        - 자식클래스의 메소드를 기억하면서 부모클래스의 메서드를 살펴봐야하기 때문에 복잡하고 이해하기가 어려워진다.
    - 클래스와 메서드를 final이나 abstract 둘 중에 하나로만 제한하면 이러한 문제가 발생할 수 있는 가능성을 없앨 수 있다.
        - 클래스가 final이면 상속을 받을 수 없다.
        - 메서드가 abstract라면 부모클래스 안에서는 abstract메서드를 구현할 수 없기 때문에 메서드를 이해하는 데 혼란스럽지 않다.
    - 클래스의 신분 3가지
        - final
        - abstract
        - final, abstract 둘 다 아닌 경우
    - 모든 클래스를 final이나 abstract로 만든다면 상속을 사용할 일이 없으며 오로지 캡슐화만을 이용할 수 있다.
    - 상속이 적절한 경우
        - 클래스의 행동을 확장하지 않고 정제(refine)할 때
        - 확장? 새로운 행동을 추가해서 기존의 행동을 부분적으로 보완하는 일
        - 정제? 부분적으로 불완전한 행동을 완전하게 만드는 일
        

### 느낀점

---

상속의 side effect를 다시 생각해볼 수 있어서 좋았다. 이펙티브 자바에서도 ‘상속보다는 컴포지션을 사용하라’고 했다. 상속은 확장보다는 정제를 할 때 사용하자.
