# 내용 정리

- 메서드 안에 NULL을 반환하는 로직이 있다면 그 객체를 신뢰할 수 없다. 장애를 갖고 있기 때문에 특별하게 대우(NULL 처리)를 할 필요가 있다.
- 언제나 NPE의 무서움을 갖고 있어야 한다. 이는 단순한 기술적 불편함이고 우리는 그 객체를 신뢰할 수 없다.
- 객체라는 사상에는 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다. 단순한 데이터 조각이 아니다.
- 객체는 자신만의 생명주기, 행동, 상태를 가지는 살아있는 유기체이다. 객체는 살아있으면서 존재하거나 존재하지 않으면서 죽어있는 경우밖에 없다.
- 신뢰라는 말은 객체가 자신의 행동을 책임지고(responsible) 그 행동에 대해 간섭받지 않는다는 정의가 있다.
- 객체가 반환한 값을 검사하는 방식은 애플리케이션에 대한 신뢰가 부족하다는 신호이다.
- 코드를 읽을 때 메서드 호출과 NULL 검사를 예측할 수 없다면 이해하기 위해 더 많은 시간이 걸린다.
- NULL을 반환하는 방식은 잘못되었고 보기에도 좋지 않다.
- JDK 설계자들은 빠르게 실패하기 원칙(fail fast principle)을 몰랐기 때문에 Exception 처리보다 Null을 던지는 방법을 채택했을 거라고 생각한다. 그 결과는 물론 호의적이지 않았다.

## 빠르게 실패하기 vs 안전하게 실패하기

- 소프트웨어 견고성(software robustness)과 실패 탄력회복성(failure resilience) 관련해서 상반되는 두 가지 철학이 존재한다.
    - 빠르게 실패하기(fail fast)와 안전하게 실패하기(fail safe)이다.
    - 저자는 빠르게 실패하기에 열렬한 지지자이다.
- 안전하게 실패하기
    - 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 많은 노력을 기울여야 한다.
    - 어떤 상황이 닥치더라도 소프트웨어는 생존하기 위해 노력해야 한다. NULL을 반환하는 방법도 일종의 생존 기법이라 할 수 있다.
- 빠르게 실패하기
    - 안전하게 실패하기와는 정반대이다. 문제가 발생하면 곧바로 실행을 중단하고 최대한 빨리 예외를 던진다. 결과에 대해서는 걱정하지 않는다.
    - 소프트웨어가 부서지기 쉽고 모든 단일 제어 지점(single control point)에서 중단되도록 설계됐다면 단위 테스트에서 실패 상황을 손쉽게 재현할 수 있고 문제를 쉽게 수정할 수 있다.
    - 모든 실패 지점이 명확하고 훌륭하게 문서화되어 있기 때문에 상황을 재생하는 테스트를 쉽게 추가하고 실패를 감추지 않고 강조할 수 있다.
    - 상황을 구조하지 않고 실패를 분명하게(flagrant) 만든다.

## NULL의 대안

- 첫 번째 방법은 메서드를 두 개로 나눈다. 첫 번째 메서드가 객체의 존재를 확인하고 두 번째 메서드가 객체를 반환한다. 이 방법은 데이터 베이스에 요청을 2번해야한다.
- 두 번째 방법은 NULL을 반환하거나 예외를 던지는 대신 객체 컬렉션을 반환한다.
    - 객체를 Collection으로 감싸서 반환한다. 하지만 컬렉션을 꼭 사용해야 한다.
- 세 번째 방법은 Optional 같은 도구를 사용해야 하는 경우도 있다. 하지만 메서드 이름은 user()이지만 Optional<User>를 반환해야 하므로 OOP와 대립되는 방식이다.
- 네 번째 방법은 널 객체(null object) 디자인 패턴이다. 널 객체 패턴에서는 원하는 객체를 발견하지 못할 경우 User가 아닌 NullUser를 반환하는 것이다. NullUser는 User를 상속받는다.
- 요약하면 절대 NULL을 반환하지 않아야 한다. NULL 대신 예외를 던지거나 컬렉션을 반환하거나 널 객체를 반환해야 한다.

# 느낀점

- Nullability에 대한 심도 깊은 고민이라 재미있었다. 저자의 말에 공감하며 실제로 현업에서도 NULL에 대한 고민이 많았다. 코틀린을 사용하는데 가장 큰 이점도 Nullability에 대한 제어를 컴파일 시점에서 명확하게 할 수 있다는 점이었다.
